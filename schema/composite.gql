type CompositeResource implements Node & KubernetesResource {
  id: ID!

  apiVersion: String!
  kind: String!
  metadata: ObjectMeta!
  spec: CompositeResourceSpec!
  status: CompositeResourceStatus!

  raw: JSONObject!

  events: EventConnection! @goField(forceResolver: true)
}

type CompositeResourceSpec {
  composition: Composition @goField(forceResolver: true)
  compositionSelector: LabelSelector
  claim: CompositeResourceClaim @goField(forceResolver: true)
  writesConnectionSecretTo: Secret @goField(forceResolver: true)

  resources: ComposedResourceConnection @goField(forceResolver: true)
}

type ComposedResourceConnection {
  items: [ComposedResource!]
  count: Int!
}

# TODO(negz): Do we need to support GenericResource here, just in case? We only
# support managed an composite resources officially, but in practice some folks
# use arbitrary resources.
union ComposedResource = ManagedResource | CompositeResource

type CompositeResourceStatus implements ConditionedStatus {
  conditions: [Condition!]
  connectionDetails: CompositeResourceConnectionDetails
}

type CompositeResourceConnectionDetails {
  lastPublishedTime: Time
}

type CompositeResourceClaim implements Node & KubernetesResource {
  id: ID!

  apiVersion: String!
  kind: String!
  metadata: ObjectMeta!
  spec: CompositeResourceClaimSpec!
  status: CompositeResourceClaimStatus!

  raw: JSONObject!

  events: EventConnection! @goField(forceResolver: true)
}

type CompositeResourceClaimSpec {
  composition: Composition @goField(forceResolver: true)
  compositionSelector: LabelSelector
  resource: CompositeResource @goField(forceResolver: true)
  writesConnectionSecretTo: Secret @goField(forceResolver: true)
}

type CompositeResourceClaimStatus implements ConditionedStatus {
  conditions: [Condition!]
  connectionDetails: CompositeResourceClaimConnectionDetails
}

type CompositeResourceClaimConnectionDetails {
  lastPublishedTime: Time
}
