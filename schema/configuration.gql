type Configuration implements Node & KubernetesResource {
  id: ID!

  apiVersion: String!
  kind: String!
  metadata: ObjectMeta!
  spec: ConfigurationSpec!
  status: ConfigurationStatus

  raw: JSONObject!

  events(limit: Int): EventConnection! @goField(forceResolver: true)
  revisions(limit: Int, active: Boolean): ConfigurationRevisionConnection! @goField(forceResolver: true)
}

type ConfigurationRevisionConnection {
  items: [ConfigurationRevision!]
  count: Int!
}

# TODO(negz): Include packagePullSecrets? It seems idiomatic to resolve an array
# of actual secrets, but we're missing the information required to do so and
# it's not obvious whether returning them is useful. At the Kubernetes level we
# have an array of local object references, which do not include a namespace.
# The Secrets are presumed to be read from the namespace in which Crossplane is
# running, which we do not know.

type ConfigurationSpec {
  package: String!
  revisionActivationPolicy: RevisionActivationPolicy
  revisionHistoryLimit: Int
  packagePullPolicy: PackagePullPolicy
  ignoreCrossplaneConstraints: Boolean
  skipDependencyResolution: Boolean
}

type ConfigurationStatus implements ConditionedStatus {
  conditions: [Condition!]
  currentRevision: String
  currentIdentifier: String
}

type ConfigurationRevision implements Node & KubernetesResource {
  id: ID!

  apiVersion: String!
  kind: String!
  metadata: ObjectMeta!
  spec: ConfigurationRevisionSpec!
  status: ConfigurationRevisionStatus

  raw: JSONObject!

  events(limit: Int): EventConnection! @goField(forceResolver: true)
}

type ConfigurationRevisionSpec {
  desiredState: PackageRevisionDesiredState!
  package: String!
  packagePullPolicy: PackagePullPolicy
  revision: Int!
  ignoreCrossplaneConstraints: Boolean
  skipDependencyResolution: Boolean
}

type ConfigurationRevisionStatus implements ConditionedStatus {
  conditions: [Condition!]
  foundDependencies: Int
  installedDependencies: Int
  invalidDependencies: Int
  permissionRequests: [PolicyRule!]

  # In practice these objects are currently always a CompositeResourceDefinition
  # or a Composition. Crossplane lints the content of configuration packages to
  # enforce this, but it's not enforced at the API level. We return an array of
  # KubernetesResource here because doing so allows us to package different
  # types in future without a breaking GraphQL schema change.

  objects(limit: Int): KubernetesResourceConnection! @goField(forceResolver: true)
}
