type Provider implements Node & KubernetesResource {
  id: ID!

  apiVersion: String!
  kind: String!
  metadata: ObjectMeta!
  spec: ProviderSpec!
  status: ProviderStatus

  raw: JSONObject!

  events: EventConnection! @goField(forceResolver: true)
  revisions(active: Boolean): ProviderRevisionConnection! @goField(forceResolver: true)
}

type ProviderRevisionConnection {
  items: [ProviderRevision!]
  count: Int!
}

# TODO(negz): Include packagePullSecrets? It seems idiomatic to resolve an array
# of actual secrets, but we're missing the information required to do so and
# it's not obvious whether returning them is useful. At the Kubernetes level we
# have an array of local object references, which do not include a namespace.
# The Secrets are presumed to be read from the namespace in which Crossplane is
# running, which we do not know.

type ProviderSpec {
  package: String!
  revisionActivationPolicy: RevisionActivationPolicy
  revisionHistoryLimit: Int
  packagePullPolicy: PackagePullPolicy
  ignoreCrossplaneConstraints: Boolean
  skipDependencyResolution: Boolean
}

type ProviderStatus implements ConditionedStatus {
  conditions: [Condition!]
  currentRevision: String
  currentIdentifier: String
}

type ProviderRevision implements Node & KubernetesResource {
  id: ID!

  apiVersion: String!
  kind: String!
  metadata: ObjectMeta!
  spec: ProviderRevisionSpec!
  status: ProviderRevisionStatus

  raw: JSONObject!

  events: EventConnection! @goField(forceResolver: true)
}

type ProviderRevisionSpec {
  desiredState: PackageRevisionDesiredState!
  package: String!
  packagePullPolicy: PackagePullPolicy
  revision: Int!
  ignoreCrossplaneConstraints: Boolean
  skipDependencyResolution: Boolean

}

type ProviderRevisionStatus implements ConditionedStatus {
  conditions: [Condition!]
  foundDependencies: Int
  installedDependencies: Int
  invalidDependencies: Int
  permissionRequests: [PolicyRule!]

  # In practice these objects are currently always a CustomResourceDefinition.
  # Crossplane lints the content of provider packages to enforce this, but it's
  # not enforced at the API level. We return an array of KubernetesResource here
  # because doing so allows us to package different types in future without a
  # breaking GraphQL schema change.

  objects: KubernetesResourceConnection! @goField(forceResolver: true)
}
