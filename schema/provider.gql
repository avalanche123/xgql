type Provider implements KubernetesResource {
  apiVersion: String!
  kind: String!
  metadata: ObjectMeta!
  spec: ProviderSpec!
  status: ProviderStatus

  raw: JSONObject!

  events(limit: Int): EventConnection! @goField(forceResolver: true)
  revisions(limit: Int, active: Boolean): ProviderRevisionConnection! @goField(forceResolver: true)
}

type ProviderRevisionConnection {
  items: [ProviderRevision!]
  count: Int!
}

# TODO(negz): Include packagePullSecrets? It seems idiomatic to resolve an array
# of actual secrets, but we're missing the information required to do so and
# it's not obvious whether returning them is useful. At the Kubernetes level we
# have an array of local object references, which do not include a namespace.
# The Secrets are presumed to be read from the namespace in which Crossplane is
# running, which we do not know.

type ProviderSpec {
  package: String!
  revisionActivationPolicy: RevisionActivationPolicy
  revisionHistoryLimit: Int
  packagePullPolicy: PackagePullPolicy
  ignoreCrossplaneConstraints: Boolean
  skipDependencyResolution: Boolean
}

type ProviderStatus implements ConditionedStatus {
  conditions: [Condition!]
  currentRevision: String
  currentIdentifier: String
}

type ProviderRevision implements KubernetesResource {
  apiVersion: String!
  kind: String!
  metadata: ObjectMeta!
  spec: ProviderRevisionSpec!
  status: ProviderRevisionStatus

  raw: JSONObject!

  events(limit: Int): EventConnection! @goField(forceResolver: true)
}

type ProviderRevisionSpec {
  desiredState: PackageRevisionDesiredState!
  package: String!
  packagePullPolicy: PackagePullPolicy
  revision: Int!
  ignoreCrossplaneConstraints: Boolean
  skipDependencyResolution: Boolean

}

type ProviderRevisionStatus implements ConditionedStatus {
  conditions: [Condition!]
  foundDependencies: Int
  installedDependencies: Int
  invalidDependencies: Int
  permissionRequests: [PolicyRule!]

  objects(limit: Int): KubernetesResourceConnection! @goField(forceResolver: true)
}
